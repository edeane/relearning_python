"""
Explore vs. Exploit Dilemma
- Multi Armed Bandit

Should you explore other options or exploit the option that is providing the best results...

Bayesian
https://en.wikipedia.org/wiki/Conjugate_prior

"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from scipy import stats
plt.interactive(False)


pd.set_option('display.max_rows', 10)
pd.set_option('display.max_columns', 100)
pd.set_option('display.width', 1_000)
np.set_printoptions(suppress=True)

def flatten_cols(df, sep='_'):
    col_res = []
    for idx, col_names in enumerate(df.columns.values):
        col_names = [i for i in col_names if i != '']
        col_res.append(sep.join(col_names).strip())
    df.columns = col_res
    return df

pd.DataFrame.flatten_cols = flatten_cols

n_rounds = 10_000
bandits_payout = (0.1, 0.2, 0.3)
# bandit_df = pd.DataFrame({'bandit_sel': [], 'random': [], 'bandit_res': []})
bandit_df = np.zeros(n_rounds, dtype=[('bandit_sel', 'int'),
                                      ('random', 'int'),
                                      ('bandit_res', 'int')])

eps_greedy_rand = 0.1

for n_round in range(n_rounds):

    if n_round == 0 or np.random.random() <= eps_greedy_rand:
        bandit_sel = np.random.randint(0, len(bandits_payout))
        bandit_df['random'][n_round] = 1
    else:
        bandit_pers = []
        for i in range(len(bandits_payout)):
            bandit_slice = bandit_df[0:n_round]
            bandit_slice = bandit_slice[bandit_slice['bandit_sel'] == i]
            if bandit_slice['bandit_res'].shape[0] > 0:
                bandit_pers.append(bandit_slice['bandit_res'].mean())
            else:
                bandit_pers.append(0)
        bandit_sel = np.array(bandit_pers).argmax()
        bandit_df['random'][n_round] = 0

    bandit_res = 1 if (np.random.random() <= bandits_payout[bandit_sel]) else 0
    bandit_df['bandit_sel'][n_round] = bandit_sel
    bandit_df['bandit_res'][n_round] = bandit_res


bandit_df
bandit_pers




# ---------------------------
# Video Demo Section --------
# ---------------------------


stats.beta


NUM_TRIALS = 2_000
BANDIT_PROBABILITIES = [0.25, 0.5, 0.75]


class Bandit:
    def __init__(self, p):
        self.p = p
        self.a = 1
        self.b = 1

    def pull(self):
        return np.random.random() < self.p

    def sample(self):
        return np.random.beta(self.a, self.b)

    def update(self, x):
        self.a += x
        self.b += 1 - x

def plot(bandits, trial):
    fig, ax = plt.subplots(1, 1)
    x = np.linspace(0, 1, 200)
    for b in bandits:
        y = stats.beta.pdf(x, b.a, b.b)
        plt.plot(x, y, label=f'real p: {b.p:.4f}')
    plt.title(f'Bandit distributions after {trial} trials')
    plt.legend()
    plt.savefig(f'W:/work/bandit_{trial}.png')
    # plt.show()


def experiment():
    bandits = [Bandit(p) for p in BANDIT_PROBABILITIES]
    sample_points = [5, 10, 20, 50, 100, 200, 500, 1_000, 1_500, 1_999]
    for i in range(NUM_TRIALS):
        bestb = None
        maxsample = -1
        allsamples = []
        for b in bandits:
            sample = b.sample()
            allsamples.append(f'{sample:.4f}')
            if sample > maxsample:
                maxsample = sample
                bestb = b
        if i in sample_points:
            print(f'current samples: {allsamples}')
            plot(bandits, i)

        x = bestb.pull()
        bestb.update(x)



experiment()


# ---------------------------
# Convergence --------
# ---------------------------

def run_experiment(p1, p2, p3, N):
    bandits = [Bandit(p1), Bandit(p2), Bandit(p3)]

    data = np.empty(N)

    for i in range(N):
        j = np.argmax([b.sample() for b in bandits])
        x = bandits[j].pull()
        bandits[j].update(x)
        data[i] = x

    cum_avg_ctr = np.cumsum(data) / (np.arange(N) + 1)

    plt.plot(cum_avg_ctr)
    plt.plot(np.ones(N) * p1)
    plt.plot(np.ones(N) * p2)
    plt.plot(np.ones(N) * p3)
    plt.ylim((0, 1))
    plt.xscale('log')
    plt.show()

run_experiment(.2, .25, .3, 10_000)

# side
# reservoir sampling


class ReservoirClassic():
    def __init__(self, max_size):
        self.samples = []
        self.max_size = max_size
        self.i = 0

    def add(self, element, timestamp):
        size = len(self.samples)
        if size >= self.max_size:
            spot = random.randint(0, self.i - 1)
            if spot < size:
                self.samples[spot] = (element, timestamp)
        else:
            self.samples.append((element, timestamp))

        self.i += 1



rc = ReservoirClassic(500)
rc.add()

def random_subset(iterator, K):
    result = []
    N = 0
    for idx, item in enumerate(iterator):
        N += 1
        if len(result) < K:
            s = 0
            result.append(item)
        else:
            s = int(random.random() * N)
            if s < K:
                result[s] = item
    return result

means = []
for i in range(1_000):
    rs = random_subset(range(1_000), 100)
    means.append(np.mean(rs))

means
sns.distplot(means)
plt.show()
np.mean(means)
np.mean(range(1_000))

# ---------------------------
# Confidence Interval -------
# ---------------------------



T = 501
true_ctr = 0.5
a, b = 1, 1
plot_indicies = (10, 20, 30, 50, 100, 200, 500)
data = np.empty(T)
for i in range(T):
    x = 1 if np.random.random() < true_ctr else 0
    data[i] = x
    a += x
    b += 1 - x

    if i in plot_indicies:
        p = data[:i].mean()
        n = 1 + i
        std = np.sqrt(p * (1-p) / n)
        x = np.linspace(0, 1, 200)
        g = stats.norm.pdf(x, loc=p, scale=std)
        fig, ax = plt.subplots(1, 1)
        plt.plot(x, g, label='Gaussian Approx')

        posterior = stats.beta.pdf(x, a=a, b=b)
        plt.plot(x, posterior, label='Beta Posterior')
        plt.legend()
        plt.title(f'N = {n}')
        plt.show()





















































